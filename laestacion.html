<html>
<head>
<title>TP Gráficos - 1c2016</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="antena.js"></script>
<script type="text/javascript" src="buffer_vertices.js"></script>
<script type="text/javascript" src="cilindro.js"></script>
<script type="text/javascript" src="circunferencia.js"></script>
<script type="text/javascript" src="circunferenciaXZ.js"></script>
<script type="text/javascript" src="color.js"></script>
<script type="text/javascript" src="cubo.js"></script>
<script type="text/javascript" src="cuerpoCentralNave.js"></script>
<script type="text/javascript" src="cuerpoNave.js"></script>
<script type="text/javascript" src="curvaBezier.js"></script>
<script type="text/javascript" src="curvaBSpline.js"></script>
<script type="text/javascript" src="ejeTurbinas.js"></script>
<script type="text/javascript" src="esfera.js"></script>
<script type="text/javascript" src="estacion.js"></script>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript" src="keyboardhandle.js"></script>
<script type="text/javascript" src="modeloNave.js"></script>
<script type="text/javascript" src="mousehandle.js"></script>
<script type="text/javascript" src="nave.js"></script>
<script type="text/javascript" src="paralelepipedo.js"></script>
<script type="text/javascript" src="parteCentral.js"></script>
<script type="text/javascript" src="parteExterior.js"></script>
<script type="text/javascript" src="pata.js"></script>
<script type="text/javascript" src="productoVectorial.js"></script>
<script type="text/javascript" src="seccionAntena.js"></script>
<script type="text/javascript" src="shaderProgram.js"></script>
<script type="text/javascript" src="startDraw.js"></script>
<script type="text/javascript" src="superficieBarrido.js"></script>
<script type="text/javascript" src="superficieRevolucion.js"></script>
<script type="text/javascript" src="tapa.js"></script>
<script type="text/javascript" src="textureHandler.js"></script>
<script type="text/javascript" src="turbina.js"></script>
<script type="text/javascript" src="utils.js"></script>
<script type="text/javascript" src="vertice.js"></script>

<!-- <script id="shaderNormal-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying vec3 vNormal;
    varying mat3 toLocalObject;

    varying vec3 vLightWeighting;

    uniform sampler2D uSampler;
    uniform sampler2D uSamplerNormalMap;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        vec3 nMap         = texture2D(uSamplerNormalMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb; 
        vec3 normalMap    = (nMap * 2.0 - 1.0);
        //TODO: Acá se debería utilizar este normal map para Phong
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
    }
</script>

<script id="shaderNormal-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aVertexTangent;
    attribute vec3 aVertexBinormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying vec3 vNormal;
    varying mat3 toLocalObject;

    varying vec3 vLightWeighting;

    void main(void) {
        vPosition = uModelMatrix * vec4(aVertexPosition, 1.0);

        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * vPosition;

        // Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;

        // Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;

        vec3 normal   = normalize(uNMatrix * aVertexNormal);
        vec3 tangente = normalize(uNMatrix * aVertexTangent);
        vec3 binormal = normalize(uNMatrix * aVertexBinormal);

        vNormal = normal;

        // Matriz para pasar de coordenadas de vista a coordenadas intrinsecas (coordenadas para hacer el normal mapping)
        toLocalObject = mat3(   tangente.x, binormal.x, normal.x,
                                tangente.y, binormal.y, normal.y,
                                tangente.z, binormal.z, normal.z ) ;

        // Calculos de la iluminación
        vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
        normalize(light_dir);
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting * 0.1;
        }
    }
</script> -->

<script id="shaderTextura-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;
    varying vec3 vLightWeighting;
    varying vec3 reflectionDir;
    varying float vUseReflection;

    uniform sampler2D uSampler;
    uniform sampler2D uSamplerReflectionMap;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        // Si utiliza reflexion
        if (vTextureCoord[2] == 1.0 || vUseReflection == 1.0) {
            vec4 reflectionTexture = texture2D(uSamplerReflectionMap, vec2(reflectionDir.x, reflectionDir.y));
            //gl_FragColor = vec4(mix(textureColor, reflectionTexture, 0.3).rgb * vLightWeighting, textureColor.a);

            //gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);

            // Probando...
            vec4 reflectionTextureMock = texture2D(uSamplerReflectionMap, vec2(vTextureCoord.s, vTextureCoord.t));
            gl_FragColor = vec4(reflectionTextureMock.rgb * vLightWeighting, textureColor.a);
        }
    }
</script>

<script id="shaderTextura-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 worldCameraPosition;

    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform float uUseReflection;
    uniform bool uUseLighting;

    varying vec3 vTextureCoord;
    varying vec3 vLightWeighting;
    varying vec3 reflectionDir;
    varying float vUseReflection;

    void main(void) {
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

        // Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;

        // Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;

        // Indica si usa reflection
        vUseReflection = uUseReflection;

        // Calculos de la iluminación
        vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
        normalize(light_dir);
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting * 0.1;
        }

        vec3 worldPos  = vec3( uModelMatrix * vec4(aVertexPosition,1.0) );
        vec3 worldNorm = vec3( uModelMatrix * vec4(aVertexNormal,  0.0) ); 
        vec3 worldView = normalize( worldCameraPosition - worldPos ); 
        reflectionDir  = reflect( -worldView, worldNorm );
        //reflectionDir.y -= 0.15;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    //uniform sampler2D uSampler;

    void main(void) {
        //vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(vTextureCoord.rgb * vLightWeighting, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

        // Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;

        // Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;

        // Calculos de la iluminación
        vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
        normalize(light_dir);
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting * 0.1;
        }
    }
</script>

<script type="text/javascript">

    // Variable global para el contexto GL
    var gl;

    // Variables de la estacion
    var cameraMatrix    = mat4.create();
    var mvMatrix        = mat4.create();
    var pMatrix         = mat4.create();
    var camaraAux       = mat4.create();
    var eye_point       = vec3.create();
    vec3.set(eye_point, 0, 0, 0);
    var up_point        = vec3.create();
    vec3.set(up_point, 0, 1, 0);
    var at_point        = vec3.create();
    vec3.set(at_point, 0, 0, 0);

    // Variables de las cámaras
    var mouseDown           = false;
    var camaraCabina        = false;
    var camaraPersecucion   = false;
    var camaraPersona       = false;
    var camaraGlobal        = true;
    var mouseX              = 0.0;
    var mouseY              = 0.0;
    var rotarCamaraX        = 0.0;
    var rotarCamaraXPersona = 0.0;
    var rotarCamaraY        = -45.0;
    var rotarCamaraYPersona = 0.0;
    var aumento             = 0.0;
    var traslacionPersonaX  = -59.0;
    var traslacionPersonaZ  = 3.0;
    var traslacionNave      = vec3.create();
    vec3.set(traslacionNave, 0, 0, 0);

    // Variables de la Antena
    var desplegarAntena         = true;
    var plegarAntena            = false;
    var plegarODesplegarAntena  = false;
    var deltaAntenaTraslacion   = 0;
    var deltaAntenaRotacion     = 0;
    var traslacionPlegadoAntena = 0.0;
    var rotacionPlegadoAntena   = 0.0;
    var finRotacionAntena       = true;

    // Variables de la Nave
    var rotacionEjeNave         = -Math.PI/2;
    var cabezeoNave             = null;
    var viradaNave              = null;
    var rolidoNave              = null;
    var naveVertical            = false;
    var plegarODesplegarPatas   = false;
    var plegarPatas             = false;
    var desplegarPatas          = false;
    var traslacionPatasNave     = -4.9;
    var deltaPatas              = 0;

    // Astronauta
    var model_matrix_astronauta = null;

    // Variables de los elementos de la escena
    var nave        = null;
    var modeloNave  = null;
    var estacion    = null;
    var sol         = null;
    var tierra      = null;
    var universo    = null;
    var astronauta  = null;
    var rotacionSol = 0.0;

    // Variables de los shaders
    var shaderProgramSimple;
    var shaderProgramTextura;
    var shaderProgramNormal;
</script>

</head>
<body onload="start();">
    <center>
        <h1>Sistemas Gráficos - 66.71</h1>
        <h2>Trabajo Pr&aacute;ctico 2016</h2>
        <canvas id="glcanvas" style="border: none;" width="1280" height="720">
        Your browser does not support the HTML5 canvas element.
        </scanvas>
    </center>
    <br/>
    <br/>
</body>
</html>
