<html>
<head>
<title>TP Gráficos - 1c2016</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="antena.js"></script>
<script type="text/javascript" src="buffer_vertices.js"></script>
<script type="text/javascript" src="cilindro.js"></script>
<script type="text/javascript" src="circunferencia.js"></script>
<script type="text/javascript" src="color.js"></script>
<script type="text/javascript" src="cubo.js"></script>
<script type="text/javascript" src="curvaBezier.js"></script>
<script type="text/javascript" src="curvaBSpline.js"></script>
<script type="text/javascript" src="esfera.js"></script>
<script type="text/javascript" src="estacion.js"></script>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript" src="keyboardhandle.js"></script>
<script type="text/javascript" src="mousehandle.js"></script>
<script type="text/javascript" src="nave.js"></script>
<script type="text/javascript" src="parteCentral.js"></script>
<script type="text/javascript" src="parteExterior.js"></script>
<script type="text/javascript" src="productoVectorial.js"></script>
<script type="text/javascript" src="seccionAntena.js"></script>
<script type="text/javascript" src="shaderProgram.js"></script>
<script type="text/javascript" src="superficieBarrido.js"></script>
<script type="text/javascript" src="superficieRevolucion.js"></script>
<script type="text/javascript" src="tapa.js"></script>
<script type="text/javascript" src="textureHandler.js"></script>
<script type="text/javascript" src="vertice.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    //uniform sampler2D uSampler;

    void main(void) {
        //vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(vTextureCoord.rgb * vLightWeighting, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
        
        // Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;
        
        // Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;
                            
        // Calculos de la iluminación
        vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
        normalize(light_dir);
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>


<script type="text/javascript">

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {

        } if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    //Variables de la estacion
    var cameraMatrix	= mat4.create();
    var mvMatrix		= mat4.create();
    var pMatrix			= mat4.create();
    var camaraAux		= mat4.create();
	var eye_point		= vec3.create();
    var up_point		= vec3.create();
    var at_point		= vec3.create();
    vec3.set(up_point, 0, 1, 0);

    var mouseDown           = false;
    var camaraCabina        = false;
    var camaraPersecucion   = false;
    var camaraPersona       = false;
    var camaraGlobal        = true;
    var mouseX              = 0.0;
    var mouseY              = 0.0;
    var rotarCamaraX        = 0.0;
    var rotarCamaraY        = -45.0;
    var aumento             = 0.0;
    var traslacionPersonaX  = 0.0;
    var traslacionPersonaZ  = 0.0;

    //Antena
    var antenaDesplegada 		= true;
    var antenaPlegada 			= false;
    var plegarODesplegarAntena 	= false;

    var estacion	= null;
	var nave		= null;
	var modeloNave	= null;
    var sol         = null;
    var rotacionSol = 0.0;
    var tierra      = null;

    function drawScene() {
        // Se configura el viewport dentro de área ¨canvas¨. en este caso se utiliza toda el área disponible
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        
        // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Configuración de la luz
        // Se inicializan las variables asociadas con la Iluminación
        var lighting = true;
        gl.uniform1i(shaderProgram.useLightingUniform, lighting);       
        var lightPosition = vec3.fromValues(500.0*Math.cos(rotacionSol), 500.0*Math.sin(rotacionSol), -150.0); 
        //vec3.transformMat4(lightPosition, lightPosition, cameraMatrix);
        gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);

        // Se configura la matriz de perspectiva
        mat4.perspective(pMatrix, degToRad(80), gl.viewportWidth / gl.viewportHeight, 0.01, 2000.0);           
        
        // Definimos la ubicación de la camara
        mat4.identity(cameraMatrix);
        mat4.identity(camaraAux);

        if(camaraGlobal) {
        	vec3.set(eye_point, 0, 0, -150 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(cameraMatrix, cameraMatrix, degToRad(rotarCamaraX));
            mat4.rotateY(cameraMatrix, cameraMatrix, degToRad(rotarCamaraY));
        }

        if(camaraCabina) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point); 
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        if(camaraPersecucion) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        if(camaraPersona) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        //Asigno las matrices para las camaras de vista y perspectiva.
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.ViewMatrixUniform, false, cameraMatrix);

        // Dibujamos la estacion        
        // Configuramos la iluminación
        gl.uniform3f(shaderProgram.ambientColorUniform, 0.3, 0.3, 0.3 );
        gl.uniform3f(shaderProgram.directionalColorUniform, 0.05, 0.05, 0.05);

        var model_matrix_escena = mat4.create();
        mat4.identity(model_matrix_escena);
        mat4.rotate(model_matrix_escena, model_matrix_escena, Math.PI/2, [1,0,0]);
        mat4.rotate(model_matrix_escena, model_matrix_escena, Math.PI, [0,1,0]);


        // Matriz de modelado de la estacion
        var model_matrix_estacion = mat4.create();
        mat4.identity(model_matrix_estacion);
        mat4.scale(model_matrix_estacion, model_matrix_escena, [7.0, 7.0, 7.0]);
        estacion.draw(model_matrix_estacion);

        // Matriz de modelado del sol
        var model_matrix_sol = mat4.create();
        mat4.identity(model_matrix_sol);
        mat4.rotate(model_matrix_sol, model_matrix_escena, rotacionSol, [0,0,1]);
        mat4.translate(model_matrix_sol, model_matrix_sol, [500.0, 0.0, -150.0]);
        mat4.scale(model_matrix_sol, model_matrix_sol, [20.0, 20.0, 20.0]);
        sol.draw(model_matrix_sol);

        // Matriz de modelado de la tierra
        var model_matrix_tierra = mat4.create();
        mat4.identity(model_matrix_tierra);
        //mat4.rotate(model_matrix_tierra, model_matrix_escena, rotacionSol, [0,0,1]);
        mat4.translate(model_matrix_tierra, model_matrix_tierra, [0.0, -150.0, 0.0]);
        mat4.scale(model_matrix_tierra, model_matrix_tierra, [200.0, 40.0, 200.0]);
        tierra.draw(model_matrix_tierra);

        if (plegarODesplegarAntena) {
        	if (antenaPlegada) {
        		antenaPlegada = false;
        		antenaDesplegada = true;
        	}
        	else if (antenaDesplegada) {
        		antenaDesplegada = false;
        		antenaPlegada = true;
        	}
        	plegarODesplegarAntena = false;
        }

        // Matriz de modelado de la nave
        nave.step(); 
		var position_matrix_nave = nave.getMatriz();
		mat4.translate(position_matrix_nave,position_matrix_nave,[0,10,-30]);
		//TODO: falta armar el objeto BIEN que modele la nave en la simulacion.
		modeloNave.draw(position_matrix_nave);
    }

    function tick() {
        requestAnimFrame(tick);
        rotacionSol += 0.05;
        drawScene();
    }

    function start() {
        var canvas = document.getElementById("glcanvas");
        initGL(canvas);
        var shaderProgram = initShaders(gl);

        estacion = new Estacion();
        estacion.create();

        sol = new Esfera(20, 20, getColor("red"), false);
        sol.initBuffers();

        tierra = new Esfera(20, 20, getColor("blue"), false);
        tierra.initBuffers();

        nave = new Nave();
        //Falta hacer esto BIEN.
        modeloNave = new Cubo(2,2,2,getColor("red"),false);//new ModeloNave();
        modeloNave.initBuffers();
        
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }
</script>
</head>
<body onload="start();">
    <center>
            <h1>Sistemas Gráficos - 66.71</h1>
            <h2>Trabajo Pr&aacute;ctico 2016</h2>
            <canvas id="glcanvas" style="border: none;" width="1280" height="720">
            Your browser does not support the HTML5 canvas element.
            </scanvas>
        </center>
    <br/>
    <br/>
</body>
</html>
