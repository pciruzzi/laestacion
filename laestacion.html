<html>
<head>
<title>TP Gráficos - 1c2016</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="buffer_vertices.js"></script>
<script type="text/javascript" src="cilindro.js"></script>
<script type="text/javascript" src="circunferencia.js"></script>
<script type="text/javascript" src="cubo.js"></script>
<script type="text/javascript" src="curvaBezier.js"></script>
<script type="text/javascript" src="curvaBSpline.js"></script>
<script type="text/javascript" src="esfera.js"></script>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript" src="productoVectorial.js"></script>
<script type="text/javascript" src="superficieBarrido.js"></script>
<script type="text/javascript" src="vertice.js"></script>
<script type="text/javascript" src="mousehandle.js"></script>
<script type="text/javascript" src="keyboardhandle.js"></script>
<script type="text/javascript" src="seccionAntena.js"></script>
<script type="text/javascript" src="antena.js"></script>
<script type="text/javascript" src="shaderProgram.js"></script>
<script type="text/javascript" src="textureHandler.js"></script>
<script type="text/javascript" src="nave.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    //uniform sampler2D uSampler;

    void main(void) {
        //vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(vTextureCoord.rgb * vLightWeighting, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
    
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
        
        // Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;
        
        // Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;
                            
        // Calculos de la iluminación
        vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
        normalize(light_dir);
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>


<script type="text/javascript">

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    //Variables de la estacion
    var cameraMatrix    = mat4.create();
    var mvMatrix        = mat4.create();
    var pMatrix         = mat4.create();
    var camaraAux       = mat4.create();
	var eye_point 		= vec3.create();
    var up_point 		= vec3.create();
    var at_point 		= vec3.create();
    vec3.set(up_point, 0, 1, 0);

    var mouseDown           = false;
    var camaraCabina        = false;
    var camaraPersecucion   = false;
    var camaraPersona       = false;
    var camaraGlobal        = true;
    var mouseX              = 0.0;
    var mouseY              = 0.0;
    var rotarCamaraX        = 0.0;
    var rotarCamaraY        = 0.0;
    var aumento             = 0.0;
    var traslacionPersonaX  = 0.0;
    var traslacionPersonaZ  = 0.0;

    var mars	= null;

    var deimosRotationMatrix = mat4.create();
    mat4.identity(deimosRotationMatrix);

    var deimosRotationAnglemars = 0.0;
    var phobosRotationAngledeimos = 0.0;

    function drawScene() {
        // Se configura el viewport dentro de área ¨canvas¨. en este caso se utiliza toda el área disponible
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        
        // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //////////////////////////////////////////////////////////////////////////////////////////////////////
        // Configuración de la luz
        // Se inicializan las variables asociadas con la Iluminación
        var lighting = true;
        gl.uniform1i(shaderProgram.useLightingUniform, lighting);       
        var lightPosition = vec3.fromValues(-100.0, 0.0, -60.0); 
        //vec3.transformMat4(lightPosition, lightPosition, cameraMatrix);
        gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);

        //////////////////////////////////////////////////////////////////////////////////////////////////////
        // Se configura la matriz de perspectiva
        mat4.perspective(pMatrix, degToRad(50), gl.viewportWidth / gl.viewportHeight, 0.01, 2000.0);           
        
        // Definimos la ubicación de la camara
        mat4.identity(cameraMatrix);
        mat4.identity(camaraAux);

        if(camaraGlobal) {
        	vec3.set(eye_point, 0, 0, -130 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(cameraMatrix, cameraMatrix, degToRad(rotarCamaraX));
            mat4.rotateY(cameraMatrix, cameraMatrix, degToRad(rotarCamaraY));
        }

        if(camaraCabina) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point); 
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        if(camaraPersecucion) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        if(camaraPersona) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        //Asigno las matrices para las camaras de vista y perspectiva.
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.ViewMatrixUniform, false, cameraMatrix);

        ////////////////////////////////////////////////////////////////////////////////
        //Empiezo a dibujar la escena
 
        // Dibujamos al mars        
        // Configuramos la iluminación
        gl.uniform3f(shaderProgram.ambientColorUniform, 0.3, 0.3, 0.3 );
        gl.uniform3f(shaderProgram.directionalColorUniform, 0.05, 0.05, 0.05);

        // Matriz de modelado del mars
        var model_matrix_mars = mat4.create();
        mat4.identity(model_matrix_mars);
        mat4.rotate(model_matrix_mars, model_matrix_mars,Math.PI/2, [1,0,0]);
        mat4.rotate(model_matrix_mars, model_matrix_mars,Math.PI, [0,1,0]);
        mat4.scale(model_matrix_mars, model_matrix_mars, [3.0, 3.0, 3.0]);
        mars.draw(model_matrix_mars);
    }

    function tick() {
        requestAnimFrame(tick);
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, newRotationMatrix, 0.025, [0, 1, 0]);
        mat4.multiply(newRotationMatrix, deimosRotationMatrix, deimosRotationMatrix);

        deimosRotationAnglemars += 0.0045;
        phobosRotationAngledeimos += 0.0005;
        drawScene();
    }

    function pruebaBarrido() {
        var n = 9;

        var P = [];
        //linea recta
        //P.push([0.0, 0.0, 0.0]);
        //P.push([0.0, 0.01, 0.0]);
        //P.push([3.0, 4.0, 0.0]);
        //P.push([7.5, 8.0, 0.0]);
        //P.push([12.0, 4.0, 0.0]);
        //P.push([15.0, 0.01, 0.0]);
        //P.push([15.0, 0.0, 0.0]);
        //P.push([0.0, 1.0, 0.0]);
        //P.push([0.0, 2.0, 0.0]);
        //P.push([0.0, 3.0, 0.0]);
        var x = new circunferencia(Math.PI*0, Math.PI*1.5, 4, 40);

        var tramosCamino = [];
        var camino = [];
        var cantPControl = P.length;
/*        for (var i = 0; i < cantPControl - 3; i++){
            tramosCamino.push(new curvaBSpline(P[i], P[i+1], P[i+2], P[i+3], n));
        }*/
        for (var i = 0; i < cantPControl - 3; i+=3){
            tramosCamino.push(new curvaBezier(P[i], P[i+1], P[i+2], P[i+3], n));
        }
        var cant = 0;
        for (var i in tramosCamino){
            camino = camino.concat(tramosCamino[i].getVertexBuffer());
            cant++;
        }
/*        var positionBuffer = getPositionBuffer(camino);
        for (var i = 0; i < positionBuffer.length; i+=3) {
            console.log(positionBuffer[i] + " , " + positionBuffer[i+1] + " , " + positionBuffer[i+2]);
        }*/
        console.log("Cantidad de tramos camino: " + cant);

        var Q = [];
        //pseudo circunferencia
        Q.push([2.0, 0.0, 0.0]);
        Q.push([1.0, 0.0, 1.0]);
        Q.push([-1.0, 0.0, 1.0]);
        Q.push([-2.0, 0.0, 0.0]);
        Q.push([-1.0, 0.0, -1.0]);
        Q.push([1.0, 0.0, -1.0]);
        Q.push([2.0, 0.0, 0.0]);
        var tramosForma = [];
        var forma = [];
        var cantQControl = Q.length;
        for (var i = 0; i < cantQControl - 3; i+=3){
            tramosForma.push(new curvaBezier(Q[i], Q[i+1], Q[i+2], Q[i+3], n));    
        }
        cant = 0;
        for (var i in tramosForma){
            forma = forma.concat(tramosForma[i].getVertexBuffer());
            cant++;
        }
        console.log("Cantidad de tramos forma: " + cant);

        return new SuperficieBarrido(forma, x.getVertexBuffer(), [0.0,1.0,0.0], false);
    }

    function start() {
        var canvas = document.getElementById("glcanvas");
        initGL(canvas);
        var shaderProgram = initShaders(gl);
        var colorRed = [1.0,0.0,0.0];
        var colorGreen = [0.0,1.0,0.0];
        var colorBlue = [0.0,0.0,1.0];
        var esTexturada = false;

        //mars = new Antena(2,2,2);
        mars = pruebaBarrido();
        mars.initBuffers();
        
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }
</script>
</head>
<body onload="start();">
    <center>
            <h1>Sistemas Gráficos - 66.71</h1>
            <h2>Framework Trabajo Pr&aacute;ctico 2016</h2>
            <canvas id="glcanvas" style="border: none;" width="1280" height="720">
            Your browser does not support the HTML5 canvas element.
            </scanvas>
        </center>
    <br/>
    Las texturas son cortesía de <a href="http://maps.jpl.nasa.gov/">Jet Propulsion Laboratory</a>.
    <br/>
    <br/>
</body>
</html>
