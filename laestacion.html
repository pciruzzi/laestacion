<html>
<head>
<title>TP Gráficos - 1c2016</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="antena.js"></script>
<script type="text/javascript" src="buffer_vertices.js"></script>
<script type="text/javascript" src="cilindro.js"></script>
<script type="text/javascript" src="circunferencia.js"></script>
<script type="text/javascript" src="color.js"></script>
<script type="text/javascript" src="cubo.js"></script>
<script type="text/javascript" src="cuerpoNave.js"></script>
<script type="text/javascript" src="curvaBezier.js"></script>
<script type="text/javascript" src="curvaBSpline.js"></script>
<script type="text/javascript" src="ejeTurbinas.js"></script>
<script type="text/javascript" src="esfera.js"></script>
<script type="text/javascript" src="estacion.js"></script>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript" src="keyboardhandle.js"></script>
<script type="text/javascript" src="modeloNave.js"></script>
<script type="text/javascript" src="mousehandle.js"></script>
<script type="text/javascript" src="nave.js"></script>
<script type="text/javascript" src="paralelepipedo.js"></script>
<script type="text/javascript" src="parteCentral.js"></script>
<script type="text/javascript" src="parteExterior.js"></script>
<script type="text/javascript" src="pata.js"></script>
<script type="text/javascript" src="productoVectorial.js"></script>
<script type="text/javascript" src="seccionAntena.js"></script>
<script type="text/javascript" src="shaderProgram.js"></script>
<script type="text/javascript" src="superficieBarrido.js"></script>
<script type="text/javascript" src="superficieRevolucion.js"></script>
<script type="text/javascript" src="tapa.js"></script>
<script type="text/javascript" src="textureHandler.js"></script>
<script type="text/javascript" src="turbina.js"></script>
<script type="text/javascript" src="vertice.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    //uniform sampler2D uSampler;

    void main(void) {
        //vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(vTextureCoord.rgb * vLightWeighting, 1.0);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec4 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
        
        // Transformamos al vértice al espacio de la proyección
        gl_Position = uPMatrix * pos_camera_view;
        
        // Coordenada de textura sin modifiaciones
        vTextureCoord = aTextureCoord;
                            
        // Calculos de la iluminación
        vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
        normalize(light_dir);
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
            float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>


<script type="text/javascript">

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {

        } if (! gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    //Variables de la estacion
    var cameraMatrix    = mat4.create();
    var mvMatrix        = mat4.create();
    var pMatrix         = mat4.create();
    var camaraAux       = mat4.create();
    var eye_point       = vec3.create();
    var up_point        = vec3.create();
    var at_point        = vec3.create();
    vec3.set(up_point, 0, 1, 0);

    var mouseDown           = false;
    var camaraCabina        = false;
    var camaraPersecucion   = false;
    var camaraPersona       = false;
    var camaraGlobal        = true;
    var mouseX              = 0.0;
    var mouseY              = 0.0;
    var rotarCamaraX        = 0.0;
    var rotarCamaraY        = -45.0;
    var aumento             = 0.0;
    var traslacionPersonaX  = 0.0;
    var traslacionPersonaZ  = 0.0;

    //Antena
    var desplegarAntena         = true;
    var plegarAntena            = false;
    var plegarODesplegarAntena  = false;
    var deltaAntenaTraslacion   = 0;
    var deltaAntenaRotacion     = 0;
    var traslacionPlegadoAntena = 0.0;
    var rotacionPlegadoAntena   = 0.0;
    var finRotacionAntena       = true;

    //Nave
    var nave                    = null;
    var rotacionEjeNave         = -Math.PI/2;
    var cabezeoNave             = null;
    var modeloNave              = null;
    var naveVertical            = false;
    var plegarODesplegarPatas   = false;
    var plegarPatas             = false;
    var desplegarPatas          = false;
    var traslacionPatasNave     = 0;
    var deltaPatas              = 0;
    
    var estacion    = null;
    var sol         = null;
    var rotacionSol = 0.0;
    var tierra      = null;

    function drawScene() {
        // Se configura el viewport dentro de área ¨canvas¨. en este caso se utiliza toda el área disponible
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        
        // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Configuración de la luz
        // Se inicializan las variables asociadas con la Iluminación
        var lighting = true;
        gl.uniform1i(shaderProgram.useLightingUniform, lighting);       
        var lightPosition = vec3.fromValues(500.0*Math.cos(rotacionSol), 500.0*Math.sin(rotacionSol), -300.0); 
        //vec3.transformMat4(lightPosition, lightPosition, cameraMatrix);
        gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);

        // Se configura la matriz de perspectiva
        mat4.perspective(pMatrix, degToRad(80), gl.viewportWidth / gl.viewportHeight, 0.01, 2000.0);           
        
        // Definimos la ubicación de la camara
        mat4.identity(cameraMatrix);
        mat4.identity(camaraAux);

        if(camaraGlobal) {
            vec3.set(eye_point, 0, 0, -200 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(cameraMatrix, cameraMatrix, degToRad(rotarCamaraX));
            mat4.rotateY(cameraMatrix, cameraMatrix, degToRad(rotarCamaraY));
        }

        if(camaraCabina) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point); 
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        if(camaraPersecucion) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        if(camaraPersona) {
            vec3.set(eye_point, 30, 65, -90 + aumento);
            vec3.set(at_point, 0, 0, 0);

            mat4.lookAt(cameraMatrix, eye_point, at_point, up_point);
            mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
            mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
            mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
        }

        //Asigno las matrices para las camaras de vista y perspectiva.
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.ViewMatrixUniform, false, cameraMatrix);

        // Dibujamos la escena        
        // Configuramos la iluminación
        gl.uniform3f(shaderProgram.ambientColorUniform, 0.3, 0.3, 0.3 );
        gl.uniform3f(shaderProgram.directionalColorUniform, 0.05, 0.05, 0.05);

        var model_matrix_escena = mat4.create();
        mat4.identity(model_matrix_escena);
        mat4.rotate(model_matrix_escena, model_matrix_escena, Math.PI/2, [1,0,0]);
        mat4.rotate(model_matrix_escena, model_matrix_escena, Math.PI, [0,1,0]);


        // Matriz de modelado de la estacion
        var model_matrix_estacion = mat4.create();
        mat4.identity(model_matrix_estacion);
        mat4.scale(model_matrix_estacion, model_matrix_escena, [7.0, 7.0, 7.0]);
        estacion.draw(model_matrix_estacion);

        // Matriz de modelado del sol
        var model_matrix_sol = mat4.create();
        mat4.identity(model_matrix_sol);
        mat4.rotate(model_matrix_sol, model_matrix_escena, rotacionSol, [0,0,1]);
        mat4.translate(model_matrix_sol, model_matrix_sol, [500.0, 0.0, -300.0]);
        mat4.scale(model_matrix_sol, model_matrix_sol, [20.0, 20.0, 20.0]);
        sol.draw(model_matrix_sol);

        // Matriz de modelado de la tierra
        var model_matrix_tierra = mat4.create();
        mat4.identity(model_matrix_tierra);
        mat4.translate(model_matrix_tierra, model_matrix_tierra, [0.0, -300.0, 0.0]);
        mat4.scale(model_matrix_tierra, model_matrix_tierra, [200.0, 200.0, 200.0]);
        tierra.draw(model_matrix_tierra);

        //Movimiento de las antenas
        if (plegarODesplegarAntena) {
            if (traslacionPlegadoAntena == 4.8) {
                desplegarAntena = true;
                finRotacionAntena = false;
                plegarAntena = false;
                deltaAntenaTraslacion = -0.05; //desplegar
                deltaAntenaRotacion = 0.02;
            } else if (traslacionPlegadoAntena == 0) {
                plegarAntena = true;
                desplegarAntena = false;
                finRotacionAntena = false;
                deltaAntenaTraslacion = 0.05; //plegar
                deltaAntenaRotacion = -0.02;
            }
        }

        if (plegarAntena && traslacionPlegadoAntena < 7.2) {
            if (! finRotacionAntena) {
                rotacionPlegadoAntena += deltaAntenaRotacion;
                plegarODesplegarAntena = false;
                if (rotacionPlegadoAntena < -Math.PI/2 + 0.02) {
                    finRotacionAntena = true;
                    rotacionPlegadoAntena = -Math.PI/2;
                }
            } else {
                traslacionPlegadoAntena += deltaAntenaTraslacion;
                if (traslacionPlegadoAntena > 4.75) traslacionPlegadoAntena = 4.8;
            }
        } else if (traslacionPlegadoAntena == 4.8) {
            plegarAntena = false;
        }

        if (desplegarAntena && rotacionPlegadoAntena < 0) {
            if (! finRotacionAntena) { //utilizo este booleano aunque primero traslade y despues rote
                traslacionPlegadoAntena += deltaAntenaTraslacion;
                plegarODesplegarAntena = false;
                //console.log("traslacion: " + traslacionPlegadoAntena);
                if (traslacionPlegadoAntena < 0.1) {
                    finRotacionAntena = true;
                    traslacionPlegadoAntena = 0;
                }
            } else {
                rotacionPlegadoAntena += deltaAntenaRotacion;
                if (rotacionPlegadoAntena > -0.02) rotacionPlegadoAntena = 0;
            }
        } else if (rotacionPlegadoAntena == 0) {
            desplegarAntena = false;
        }

        // Matriz de modelado de la nave
        var position_matrix_nave = mat4.create();
        mat4.identity(position_matrix_nave);
        mat4.rotate(position_matrix_nave, position_matrix_nave, -Math.PI/4-0.1, [0,1,0]);
        mat4.translate(position_matrix_nave, position_matrix_nave, [-40, -3.1, -40]);
        mat4.rotate(position_matrix_nave, position_matrix_nave, -Math.PI*3/4, [0,1,0]);
        mat4.scale(position_matrix_nave, position_matrix_nave, [0.2, 0.2, 0.2]);
        
        nave.step(); 
        var movement_matrix_nave = nave.getMatriz();
        mat4.multiply(position_matrix_nave, position_matrix_nave, movement_matrix_nave);

        //Movimientos del eje de las turbinas y demas
        rotacionEjeNave += (nave.getTeclaUp() && rotacionEjeNave < Math.PI/2) ? 0.01 : 0;
        rotacionEjeNave += (nave.getTeclaDown() && rotacionEjeNave > -Math.PI/2) ? -0.01 : 0;
        cabezeoNave = nave.getAnguloCabezeo();
        if (nave.getVelocidad() == 0 && rotacionEjeNave >= -Math.PI/2 + cabezeoNave) {
            if (rotacionEjeNave < (-Math.PI/2 + cabezeoNave) + 0.01) {
                rotacionEjeNave = -Math.PI/2 + cabezeoNave;
                naveVertical = true;
            } else {
                rotacionEjeNave -= 0.01;
            }
        } else if (! nave.getTeclaUp() && ! nave.getTeclaDown()) {
            naveVertical = false;
            if (rotacionEjeNave < 0.01 && rotacionEjeNave > -0.01) {
                rotacionEjeNave = 0;
            }
            if (rotacionEjeNave > 0) {
                rotacionEjeNave -= 0.01;
            } else if (rotacionEjeNave < 0) {
                rotacionEjeNave += 0.01;
            }
        }

        //Movimiento de las patas
        if (plegarODesplegarPatas) {
            if (traslacionPatasNave == 0) {
                desplegarPatas = true;
                plegarPatas = false;
                deltaPatas = -0.05; //desplegar
            } else if (traslacionPatasNave == -4.9) {
                plegarPatas = true;
                desplegarPatas = false;
                deltaPatas = 0.05; //plegar
            }
        }

        if (plegarPatas && traslacionPatasNave < 0) {
            traslacionPatasNave += deltaPatas;
            plegarODesplegarPatas = false;
            if (traslacionPatasNave > -0.05) traslacionPatasNave = 0;
        } else if (traslacionPatasNave == 0) {
            plegarPatas = false;
        }

        if (desplegarPatas && traslacionPatasNave > -4.9) {
            traslacionPatasNave += deltaPatas;
            plegarODesplegarPatas = false;
            if (traslacionPatasNave < -4.85) traslacionPatasNave = -4.9;
        } else if (traslacionPatasNave == -4.9) {
            desplegarPatas = false;
        }

        modeloNave.draw(position_matrix_nave);
    }

    function tick() {
        requestAnimFrame(tick);
        rotacionSol += 0.005;
        drawScene();
    }

    function start() {
        var canvas = document.getElementById("glcanvas");
        initGL(canvas);
        var shaderProgram = initShaders(gl);

        estacion = new Estacion();
        estacion.create();

        sol = new Esfera(30, 30, getColor("yellow"), false);
        sol.initBuffers();

        tierra = new Esfera(30, 30, getColor("light blue"), false);
        tierra.initBuffers();

        nave = new Nave();
        modeloNave = new ModeloNave();
        modeloNave.create();
        
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }
</script>
</head>
<body onload="start();">
    <center>
            <h1>Sistemas Gráficos - 66.71</h1>
            <h2>Trabajo Pr&aacute;ctico 2016</h2>
            <canvas id="glcanvas" style="border: none;" width="1280" height="720">
            Your browser does not support the HTML5 canvas element.
            </scanvas>
        </center>
    <br/>
    <br/>
</body>
</html>
