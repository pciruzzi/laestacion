<html>
<head>
<title>TP Gráficos - 1c2016</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="antena.js"></script>
<script type="text/javascript" src="buffer_vertices.js"></script>
<script type="text/javascript" src="cilindro.js"></script>
<script type="text/javascript" src="circunferencia.js"></script>
<script type="text/javascript" src="circunferenciaXZ.js"></script>
<script type="text/javascript" src="color.js"></script>
<script type="text/javascript" src="cubo.js"></script>
<script type="text/javascript" src="cuerpoCentralNave.js"></script>
<script type="text/javascript" src="cuerpoNave.js"></script>
<script type="text/javascript" src="curvaBezier.js"></script>
<script type="text/javascript" src="curvaBSpline.js"></script>
<script type="text/javascript" src="ejeTurbinas.js"></script>
<script type="text/javascript" src="esfera.js"></script>
<script type="text/javascript" src="estacion.js"></script>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript" src="keyboardhandle.js"></script>
<script type="text/javascript" src="modeloNave.js"></script>
<script type="text/javascript" src="mousehandle.js"></script>
<script type="text/javascript" src="nave.js"></script>
<script type="text/javascript" src="paralelepipedo.js"></script>
<script type="text/javascript" src="parteCentral.js"></script>
<script type="text/javascript" src="parteExterior.js"></script>
<script type="text/javascript" src="pata.js"></script>
<script type="text/javascript" src="productoVectorial.js"></script>
<script type="text/javascript" src="seccionAntena.js"></script>
<script type="text/javascript" src="shaderProgram.js"></script>
<script type="text/javascript" src="startDraw.js"></script>
<script type="text/javascript" src="superficieBarrido.js"></script>
<script type="text/javascript" src="superficieRevolucion.js"></script>
<script type="text/javascript" src="tapa.js"></script>
<script type="text/javascript" src="textureHandler.js"></script>
<script type="text/javascript" src="turbina.js"></script>
<script type="text/javascript" src="utils.js"></script>
<script type="text/javascript" src="vertice.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vTextureCoord;
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vBinormal;
    varying vec3 reflectionDir;

    varying float vUseReflection;
    uniform bool uUseColor;
    uniform bool uUseNormal;
    uniform bool uUseIlumination;
    uniform float uIluminationIntensity;

    uniform sampler2D uSampler;
    uniform sampler2D uSamplerReflectionMap;
    uniform sampler2D uSamplerNormalMap;
    uniform sampler2D uSamplerIluminationMap;

    uniform vec3 uAmbientColor;
    uniform bool uUseLighting;
    uniform bool uUsePunctualLights;

    // Sol: Direccional
    uniform vec3 uPrincipalLightDirection;
    uniform vec3 uPrincipalDiffuseColor;
    uniform vec3 uPrincipalSpecularColor;
    uniform float uPrincipalLightIntensity;

    // Tierra: Direccional
    uniform vec3 uSecondaryLightDirection;
    uniform vec3 uSecondaryDiffuseColor;
    uniform vec3 uSecondarySpecularColor;
    uniform float uSecondaryLightIntensity;

    // Luces en la Bahia de Carga: Puntuales
    uniform float uPunctualLightRadio;
    uniform float uPunctualLightIntensity;
    uniform vec3 uPunctualDiffuseColor;
    uniform vec3 uPunctualSpecularColor;
    uniform vec3 uPunctual1LightPosition;
    uniform vec3 uPunctual2LightPosition;
    uniform vec3 uPunctual3LightPosition;
    uniform vec3 uPunctual4LightPosition;

    void main(void) {
        vec3 normal = normalize(vNormal);

        // Normal Map
        if (uUseNormal) {
            vec3 tangente = normalize(vTangent);
            vec3 binormal = normalize(vBinormal);

            // Matriz para pasar de coordenadas de vista a coordenadas intrinsecas (coordenadas para hacer el normal mapping)
            mat3 toLocalObject = mat3(tangente, binormal, normal);
            vec3 nMap         = texture2D(uSamplerNormalMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb; 
            vec3 normalMap    = (nMap * 2.0 - 1.0);
            normal            = normalize(toLocalObject * normalMap);
        }

        // Calculos de la iluminación
        /** Sol: Direccional **/
        vec3 lightDir = uPrincipalLightDirection;
        vec3 lightDirNormalized = normalize(lightDir);
        vec3 viewDir = normalize(-vPosition);
        float diffusePrincipalLightWeighting = max(dot(lightDirNormalized,normal), 0.0);    // Difusa: (N*L)
        vec3 r = 2.0 * diffusePrincipalLightWeighting * normal - lightDirNormalized;
        float rv = max(dot(r, viewDir), 0.0); 
        float specularPrincipalLightWeighting = pow(rv,15.0);                               // Especular: [(2*(N*L)*N - L) * V] ^ alpha

        /** Tierra: Direccional **/
        lightDir = uSecondaryLightDirection;
        lightDirNormalized = normalize(-lightDir);
        viewDir = normalize(-vPosition);
        float diffuseSecondaryLightWeighting = max(dot(lightDirNormalized,normal), 0.0);    // Difusa: (N*L)
        r = 2.0 * diffuseSecondaryLightWeighting * normal - lightDirNormalized;
        rv = max(dot(r, viewDir), 0.0); 
        float specularSecondaryLightWeighting = pow(rv,7.0);                                // Especular: [(2*(N*L)*N - L) * V] ^ alpha

        /** Techo Bahia de Carga: Puntuales **/
        /** Puntual 1 **/
        lightDir = uPunctual1LightPosition - vPosition;
        lightDirNormalized = normalize(lightDir);
        viewDir = normalize(-vPosition);  
        float diffusePunctualLightWeighting = max(dot(lightDirNormalized,normal), 0.0); // Difusa: (N*L)
        r = 2.0 * diffusePunctualLightWeighting * normal - lightDirNormalized;
        rv = max(dot(r, viewDir), 0.0); 
        float specularPunctualLightWeighting = pow(rv,7.0);                             // Especular: [(2*(N*L)*N - L) * V] ^ alpha
        // Total
        vec3 vP1LightWeighting = uPunctualLightIntensity * (uPunctualDiffuseColor*diffusePunctualLightWeighting + 
                                                            uPunctualSpecularColor*specularPunctualLightWeighting);
        // Are Vertex inside Punctual Light Radio ?
        float dist = sqrt(pow(lightDir[0], 2.0) + pow(lightDir[1], 2.0) + pow(lightDir[2], 2.0));
        if ( dist > uPunctualLightRadio ) {
            vP1LightWeighting = 0.0 * uPunctualDiffuseColor;
        }

        /** Puntual 2 **/
        lightDir = uPunctual2LightPosition - vPosition;
        lightDirNormalized = normalize(lightDir);
        viewDir = normalize(-vPosition);
        diffusePunctualLightWeighting = max(dot(lightDirNormalized,normal), 0.0);   // Difusa: (N*L)
        r = 2.0 * diffusePunctualLightWeighting * normal - lightDirNormalized;  // Especular: [(2*(N*L)*N - L) * V] ^ alpha
        rv = max(dot(r, viewDir), 0.0); 
        specularPunctualLightWeighting = pow(rv,7.0);
        // Total
        vec3 vP2LightWeighting = uPunctualLightIntensity * (uPunctualDiffuseColor*diffusePunctualLightWeighting + 
                                                            uPunctualSpecularColor*specularPunctualLightWeighting);
        // Are Vertex inside Punctual Light Radio ?
        dist = sqrt(pow(lightDir[0], 2.0) + pow(lightDir[1], 2.0) + pow(lightDir[2], 2.0));
        if ( dist > uPunctualLightRadio ) {
            vP2LightWeighting = 0.0 * uPunctualDiffuseColor;
        }

        /** Puntual 3 **/
        lightDir = uPunctual3LightPosition - vPosition;
        lightDirNormalized = normalize(lightDir);
        viewDir = normalize(-vPosition);  
        diffusePunctualLightWeighting = max(dot(lightDirNormalized,normal), 0.0);   // Difusa: (N*L)
        r = 2.0 * diffusePunctualLightWeighting * normal - lightDirNormalized;      // Especular: [(2*(N*L)*N - L) * V] ^ alpha
        rv = max(dot(r, viewDir), 0.0); 
        specularPunctualLightWeighting = pow(rv,7.0);
        // Total
        vec3 vP3LightWeighting = uPunctualLightIntensity * (uPunctualDiffuseColor*diffusePunctualLightWeighting + 
                                                            uPunctualSpecularColor*specularPunctualLightWeighting); 
        // Are Vertex inside Punctual Light Radio ?
        dist = sqrt(pow(lightDir[0], 2.0) + pow(lightDir[1], 2.0) + pow(lightDir[2], 2.0));
        if ( dist > uPunctualLightRadio ) {
            vP3LightWeighting = 0.0 * uPunctualDiffuseColor;
        }

        /** Puntual 4 **/
        lightDir = uPunctual4LightPosition - vPosition;
        lightDirNormalized = normalize(lightDir);
        viewDir = normalize(-vPosition);
        diffusePunctualLightWeighting = max(dot(lightDirNormalized,normal), 0.0);   // Difusa: (N*L)        
        r = 2.0 * diffusePunctualLightWeighting * normal - lightDirNormalized;              
        rv = max(dot(r, viewDir), 0.0); 
        specularPunctualLightWeighting = pow(rv,7.0);                               // Especular: [(2*(N*L)*N - L) * V] ^ alpha
        // Total
        vec3 vP4LightWeighting = uPunctualLightIntensity * (uPunctualDiffuseColor*diffusePunctualLightWeighting + 
                                                            uPunctualSpecularColor*specularPunctualLightWeighting);
        // Are Vertex inside Punctual Light Radio ?
        dist = sqrt(pow(lightDir[0], 2.0) + pow(lightDir[1], 2.0) + pow(lightDir[2], 2.0));
        if ( dist > uPunctualLightRadio ) {
            vP4LightWeighting = 0.0 * uPunctualDiffuseColor;
        }

        // Use Directional Lights ?
        if (! uUseLighting) {
            diffusePrincipalLightWeighting = 0.0;
            specularPrincipalLightWeighting = 0.0;
            diffuseSecondaryLightWeighting = 0.0;
            specularSecondaryLightWeighting = 0.0;
        }

        // Use Punctual Lights ?
        if (!uUsePunctualLights) {
            vP1LightWeighting = 0.0 * uPunctualDiffuseColor;
            vP2LightWeighting = 0.0 * uPunctualDiffuseColor;
            vP3LightWeighting = 0.0 * uPunctualDiffuseColor;
            vP4LightWeighting = 0.0 * uPunctualDiffuseColor;
        }

        vec3 vPrincipalLightWeighting = uPrincipalLightIntensity * (uAmbientColor +
                                                                    uPrincipalDiffuseColor * diffusePrincipalLightWeighting + 
                                                                    uPrincipalSpecularColor * specularPrincipalLightWeighting);
        vec3 vSecondaryLightWeighting = uSecondaryLightIntensity * (uSecondaryDiffuseColor*diffuseSecondaryLightWeighting + 
                                                                    uSecondarySpecularColor *specularSecondaryLightWeighting);  
                                                                    
        vec3 vLightWeighting = vPrincipalLightWeighting + vSecondaryLightWeighting + vP1LightWeighting + vP2LightWeighting + vP3LightWeighting  + vP4LightWeighting;

        // Auto Iluminación: No le interesan el resto de las luces
        if (uUseIlumination) {
            vLightWeighting += uIluminationIntensity * texture2D(uSamplerIluminationMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        }

        vec4 textureColor;
        if (uUseColor) {
            textureColor = vec4(vTextureCoord.rgb, 1.0);
        } else {
            textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        }
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        
        // Si utiliza reflexion
        if (vTextureCoord[2] == 1.0 || vUseReflection == 1.0) {
            vec4 reflectionTexture = texture2D(uSamplerReflectionMap, vec2(reflectionDir.x, reflectionDir.y));
            gl_FragColor = vec4(mix(textureColor, reflectionTexture, 0.3).rgb * vLightWeighting, textureColor.a);

            //gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);

            // Probando...
            //vec4 reflectionTextureMock = texture2D(uSamplerReflectionMap, vec2(vTextureCoord.s, vTextureCoord.t));
            //gl_FragColor = vec4(reflectionTextureMock.rgb * vLightWeighting, textureColor.a);
        }
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aVertexTangent;
    attribute vec3 aVertexBinormal;
    attribute vec4 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uProyMatrix;
    uniform mat3 uNormalMatrix;

    uniform float uUseReflection;
    uniform vec3 worldCameraPosition;

    varying vec4 vTextureCoord;
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vBinormal;
    varying vec3 reflectionDir;

    varying float vUseReflection;

    void main(void) {
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

        // Transformamos al vértice al espacio de la proyección
        gl_Position = uProyMatrix * pos_camera_view;

        vPosition = vec3(pos_camera_view) / pos_camera_view.w;

        // Coordenada de textura sin modificaciones
        vTextureCoord = aTextureCoord;

        // Para normalMap
        vNormal = normalize(uNormalMatrix * aVertexNormal);
        vTangent = normalize(uNormalMatrix * aVertexTangent);
        vBinormal = normalize(uNormalMatrix * aVertexBinormal);


        // Indica si usa reflection.
        vUseReflection = uUseReflection;
        // Si utiliza reflexion
        if (vTextureCoord[2] == 1.0 || uUseReflection == 1.0) {
            vec3 view = normalize(vPosition);
            reflectionDir = reflect(view, vNormal);
            reflectionDir = vec3(uViewMatrix * vec4(reflectionDir, 0.0));
            //vec3 worldPos  = vec3( uModelMatrix * vec4(aVertexPosition,1.0) );
            //vec3 worldNorm = vec3( uModelMatrix * vec4(aVertexNormal,  0.0) ); 
            //vec3 worldView = normalize( worldCameraPosition - worldPos ); 
            //reflectionDir  = reflect( -worldView, worldNorm );
            //reflectionDir.y -= 0.15;
        }
    }
</script>

<script type="text/javascript">

    // Variable global para el contexto GL
    var gl;

    // Variables de la estacion
    var cameraMatrix    = mat4.create();
    var mvMatrix        = mat4.create();
    var pMatrix         = mat4.create();
    var camaraAux       = mat4.create();
    var eye_point       = vec3.create();
    vec3.set(eye_point, 0, 0, 0);
    var up_point        = vec3.create();
    vec3.set(up_point, 0, 1, 0);
    var at_point        = vec3.create();
    vec3.set(at_point, 0, 0, 0);

    // Variables de las cámaras
    var mouseDown           = false;
    var camaraCabina        = false;
    var camaraPersecucion   = false;
    var camaraPersona       = false;
    var camaraGlobal        = true;
    var mouseX              = 0.0;
    var mouseY              = 0.0;
    var rotarCamaraX        = 0.0;
    var rotarCamaraXPersona = 0.0;
    var rotarCamaraY        = -45.0;
    var rotarCamaraYPersona = 0.0;
    var aumento             = 0.0;
    var traslacionPersonaX  = -59.0;
    var traslacionPersonaZ  = 3.0;
    var traslacionNave      = vec3.create();
    vec3.set(traslacionNave, 0, 0, 0);

    // Variables de la Antena
    var desplegarAntena         = true;
    var plegarAntena            = false;
    var plegarODesplegarAntena  = false;
    var deltaAntenaTraslacion   = 0;
    var deltaAntenaRotacion     = 0;
    var traslacionPlegadoAntena = 0.0;
    var rotacionPlegadoAntena   = 0.0;
    var finRotacionAntena       = true;

    // Variables de la Nave
    var rotacionEjeNave         = -Math.PI/2;
    var cabezeoNave             = null;
    var viradaNave              = null;
    var rolidoNave              = null;
    var naveVertical            = false;
    var plegarODesplegarPatas   = false;
    var plegarPatas             = false;
    var desplegarPatas          = false;
    var traslacionPatasNave     = -4.9;
    var deltaPatas              = 0;

    // Astronauta
    var model_matrix_astronauta = null;

    // Variables de los elementos de la escena
    var nave        = null;
    var modeloNave  = null;
    var estacion    = null;
    var sol         = null;
    var tierra      = null;
    var universo    = null;
    var astronauta  = null;
    var rotacionSol = 0.0;

    // Variables de los shaders
    var shaderProgramSimple;
</script>

</head>
<body onload="start();">
    <center>
        <h1>Sistemas Gráficos - 66.71</h1>
        <h2>Trabajo Pr&aacute;ctico 2016</h2>
        <canvas id="glcanvas" style="border: none;" width="1280" height="720">
        Your browser does not support the HTML5 canvas element.
        </scanvas>
    </center>
    <br/>
    <br/>
</body>
</html>
