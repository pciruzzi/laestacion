<html>
<head>
<title>TP Gráficos - 1c2016</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="antena.js"></script>
<script type="text/javascript" src="buffer_vertices.js"></script>
<script type="text/javascript" src="cilindro.js"></script>
<script type="text/javascript" src="circunferencia.js"></script>
<script type="text/javascript" src="circunferenciaXZ.js"></script>
<script type="text/javascript" src="color.js"></script>
<script type="text/javascript" src="cubo.js"></script>
<script type="text/javascript" src="cuerpoCentralNave.js"></script>
<script type="text/javascript" src="cuerpoNave.js"></script>
<script type="text/javascript" src="curvaBezier.js"></script>
<script type="text/javascript" src="curvaBSpline.js"></script>
<script type="text/javascript" src="ejeTurbinas.js"></script>
<script type="text/javascript" src="esfera.js"></script>
<script type="text/javascript" src="estacion.js"></script>
<script type="text/javascript" src="grid.js"></script>
<script type="text/javascript" src="keyboardhandle.js"></script>
<script type="text/javascript" src="modeloNave.js"></script>
<script type="text/javascript" src="mousehandle.js"></script>
<script type="text/javascript" src="nave.js"></script>
<script type="text/javascript" src="paralelepipedo.js"></script>
<script type="text/javascript" src="parteCentral.js"></script>
<script type="text/javascript" src="parteExterior.js"></script>
<script type="text/javascript" src="pata.js"></script>
<script type="text/javascript" src="productoVectorial.js"></script>
<script type="text/javascript" src="seccionAntena.js"></script>
<script type="text/javascript" src="shaderProgram.js"></script>
<script type="text/javascript" src="startDraw.js"></script>
<script type="text/javascript" src="superficieBarrido.js"></script>
<script type="text/javascript" src="superficieRevolucion.js"></script>
<script type="text/javascript" src="tapa.js"></script>
<script type="text/javascript" src="textureHandler.js"></script>
<script type="text/javascript" src="turbina.js"></script>
<script type="text/javascript" src="utils.js"></script>
<script type="text/javascript" src="vertice.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vTextureCoord;
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vBinormal;
    //varying vec2 reflectionDir;

    varying float vUseReflection;
    uniform bool uUseColor;
    uniform bool uUseNormal;
    uniform bool uUseIlumination;
    uniform float uIluminationIntensity;

    uniform sampler2D uSampler;
    uniform sampler2D uSamplerReflectionMap;
    uniform sampler2D uSamplerNormalMap;
    uniform sampler2D uSamplerIluminationMap;

    uniform vec3 uAmbientColor;
    uniform bool uUseLighting;
    uniform bool uUsePunctualLights;

    // Sol: Direccional
    uniform vec3 uPrincipalLightDirection;
    uniform vec3 uPrincipalDiffuseColor;
    uniform vec3 uPrincipalSpecularColor;
    uniform float uPrincipalLightIntensity;

    // Tierra: Direccional
    uniform vec3 uSecondaryLightDirection;
    uniform vec3 uSecondaryDiffuseColor;
    uniform vec3 uSecondarySpecularColor;
    uniform float uSecondaryLightIntensity;

    // Luces en la Bahia de Carga: Puntuales
    uniform float uPunctualLightRadio;
    uniform float uPunctualLightIntensity;
    uniform vec3 uPunctualDiffuseColor;
    uniform vec3 uPunctualSpecularColor;

    varying vec3 diff1;
    varying float dist1;
    varying vec3 diff2;
    varying float dist2;
    /*varying vec3 diff3;
    varying float dist3;
    varying vec3 diff4;
    varying float dist4;*/

    void main(void) {
        vec3 normal = normalize(vNormal);

        // Normal Map
        if (uUseNormal) {
            vec3 tangente = normalize(vTangent);
            vec3 binormal = normalize(vBinormal);

            // Matriz para pasar de coordenadas de vista a coordenadas intrinsecas (coordenadas para hacer el normal mapping)
            mat3 toLocalObject = mat3(tangente, binormal, normal);
            vec3 nMap         = texture2D(uSamplerNormalMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb; 
            vec3 normalMap    = (nMap * 2.0 - 1.0);
            normal            = normalize(toLocalObject * normalMap);
        }

        // Calculos de la iluminación
        /** Sol: Direccional **/
        vec3 lightDir = uPrincipalLightDirection;
        vec3 lightDirNormalized = normalize(lightDir);
        vec3 viewDir = normalize(-vPosition);
        float diffusePrincipalLightWeighting = max(dot(lightDirNormalized,normal), 0.0);    // Difusa: (N*L)
        vec3 r = 2.0 * diffusePrincipalLightWeighting * normal - lightDirNormalized;
        float rv = max(dot(r, viewDir), 0.0); 
        float specularPrincipalLightWeighting = pow(rv,15.0);                               // Especular: [(2*(N*L)*N - L) * V] ^ alpha

        /** Tierra: Direccional **/
        lightDir = uSecondaryLightDirection;
        lightDirNormalized = normalize(-lightDir);
        viewDir = normalize(-vPosition);
        float diffuseSecondaryLightWeighting = max(dot(lightDirNormalized,normal), 0.0);    // Difusa: (N*L)
        r = 2.0 * diffuseSecondaryLightWeighting * normal - lightDirNormalized;
        rv = max(dot(r, viewDir), 0.0); 
        float specularSecondaryLightWeighting = pow(rv,7.0);                                // Especular: [(2*(N*L)*N - L) * V] ^ alpha

        /** Techo Bahia de Carga: Puntuales **/
        /** Puntual 1 **/
        lightDir = diff1;
        lightDirNormalized = normalize(lightDir);
        float diffusePunctualLightWeighting = max(dot(lightDirNormalized, normal), 0.0)/dist1;
        vec3 vP1LightWeighting = uPunctualLightIntensity * (uPunctualDiffuseColor*diffusePunctualLightWeighting);

        /** Puntual 2 **/
        lightDir = diff2;
        lightDirNormalized = normalize(lightDir);
        diffusePunctualLightWeighting = max(dot(lightDirNormalized, normal), 0.0)/dist2;
        vec3 vP2LightWeighting = uPunctualLightIntensity * (vec3(1.0,0.0,0.0)*diffusePunctualLightWeighting);

        /** Puntual 3 **/
        /*lightDir = diff3;
        lightDirNormalized = normalize(lightDir);
        diffusePunctualLightWeighting = max(dot(lightDirNormalized, normal), 0.0)/dist3;
        vec3 vP3LightWeighting = uPunctualLightIntensity * (vec3(1.0,1.0,0.0)*diffusePunctualLightWeighting);*/

        /** Puntual 4 **/
        /*lightDir = diff4;
        lightDirNormalized = normalize(lightDir);
        diffusePunctualLightWeighting = max(dot(lightDirNormalized, normal), 0.0)/dist4;
        vec3 vP4LightWeighting = uPunctualLightIntensity * (vec3(1.0,0.0,1.0)*diffusePunctualLightWeighting);*/

        // Use Directional Lights ?
        if (! uUseLighting) {
            diffusePrincipalLightWeighting = 0.0;
            specularPrincipalLightWeighting = 0.0;
            diffuseSecondaryLightWeighting = 0.0;
            specularSecondaryLightWeighting = 0.0;
        }

        // Use Punctual Lights ?
        if (!uUsePunctualLights) {
            vP1LightWeighting = 0.0 * uPunctualDiffuseColor;
            vP2LightWeighting = 0.0 * uPunctualDiffuseColor;
            //vP3LightWeighting = 0.0 * uPunctualDiffuseColor;
            //vP4LightWeighting = 0.0 * uPunctualDiffuseColor;
        }

        vec3 vPrincipalLightWeighting = uPrincipalLightIntensity * (uAmbientColor +
                                                                    uPrincipalDiffuseColor * diffusePrincipalLightWeighting + 
                                                                    uPrincipalSpecularColor * specularPrincipalLightWeighting);
        vec3 vSecondaryLightWeighting = uSecondaryLightIntensity * (uSecondaryDiffuseColor*diffuseSecondaryLightWeighting + 
                                                                    uSecondarySpecularColor *specularSecondaryLightWeighting);  
                                                                    
        vec3 vLightWeighting = vPrincipalLightWeighting + vSecondaryLightWeighting + vP1LightWeighting + vP2LightWeighting;// + vP3LightWeighting + vP4LightWeighting;

        // Auto Iluminación: No le interesan el resto de las luces
        if (uUseIlumination) {
            vLightWeighting += uIluminationIntensity * texture2D(uSamplerIluminationMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        }

        vec4 textureColor;
        if (uUseColor) {
            textureColor = vec4(vTextureCoord.rgb, 1.0);
        } else {
            textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        }
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        
        // Si utiliza reflexion
        if (vTextureCoord[3] == 2.0 || vUseReflection == 1.0) {
            vec3 view = normalize(vPosition);
            vec3 reflection = reflect(view, vNormal);
            float m = 2.0 * sqrt( pow(reflection.x, 2.0) + pow(reflection.y, 2.0) + pow(reflection.z + 1.0, 2.0)); 
            vec2 reflectionDir = reflection.xy / m + 0.5;
            vec4 reflectionTexture = texture2D(uSamplerReflectionMap, reflectionDir);
            //gl_FragColor = vec4(reflectionTexture, 1.0);
            gl_FragColor = vec4(mix(textureColor, reflectionTexture, 0.2).rgb * vLightWeighting, textureColor.a);

            //gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);

            // Probando...
            //vec4 reflectionTextureMock = texture2D(uSamplerReflectionMap, vec2(vTextureCoord.s, vTextureCoord.t));
            //gl_FragColor = vec4(reflectionTextureMock.rgb * vLightWeighting, textureColor.a);
        }
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec3 aVertexTangent;
    attribute vec3 aVertexBinormal;
    attribute vec4 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uProyMatrix;
    uniform mat3 uNormalMatrix;

    uniform vec3 uPunctual1LightPosition;
    uniform vec3 uPunctual2LightPosition;
    uniform vec3 uPunctual3LightPosition;
    uniform vec3 uPunctual4LightPosition;

    varying vec4 vTextureCoord;
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vBinormal;
    //varying vec2 reflectionDir;

    varying vec3 diff1;
    varying float dist1;
    varying vec3 diff2;
    varying float dist2;
    /*varying vec3 diff3;
    varying float dist3;
    varying vec3 diff4;
    varying float dist4;*/

    uniform float uUseReflection;
    varying float vUseReflection;

    void main(void) {
        // Transformamos al vértice al espacio de la cámara
        vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

        // Transformamos al vértice al espacio de la proyección
        gl_Position = uProyMatrix * pos_camera_view;

        vPosition = vec3(pos_camera_view) / pos_camera_view.w;

        // Coordenada de textura sin modificaciones
        vTextureCoord = aTextureCoord;

        // Para normalMap
        vNormal = normalize(uNormalMatrix * aVertexNormal);
        vTangent = normalize(uNormalMatrix * aVertexTangent);
        vBinormal = normalize(uNormalMatrix * aVertexBinormal);


        vec4 vmPosition = uModelMatrix * vec4(aVertexPosition, 1.0);
        diff1 = uPunctual1LightPosition - vmPosition.xyz;
        dist1 = distance(uPunctual1LightPosition, vmPosition.xyz);
        diff2 = uPunctual2LightPosition - vmPosition.xyz;
        dist2 = distance(uPunctual2LightPosition, vmPosition.xyz);
        /*diff3 = uPunctual3LightPosition - vmPosition.xyz;
        dist3 = distance(uPunctual3LightPosition, vmPosition.xyz);
        diff4 = uPunctual4LightPosition - vmPosition.xyz;
        dist4 = distance(uPunctual4LightPosition, vmPosition.xyz);*/

        // Indica si usa reflection.
        vUseReflection = uUseReflection;
        // Si utiliza reflexion
        /*if (vTextureCoord[3] == 2.0 || uUseReflection == 1.0) {
            //vec3(uViewMatrix * vec4(reflectionDir, 0.0));
        }*/
    }
</script>

<script type="text/javascript">

    // Variable global para el contexto GL
    var gl;

    // Variables de la estacion
    var cameraMatrix    = mat4.create();
    var mvMatrix        = mat4.create();
    var pMatrix         = mat4.create();
    var camaraAux       = mat4.create();
    var eye_point       = vec3.create();
    vec3.set(eye_point, 0, 0, 0);
    var up_point        = vec3.create();
    vec3.set(up_point, 0, 1, 0);
    var at_point        = vec3.create();
    vec3.set(at_point, 0, 0, 0);

    // Variables de las cámaras
    var mouseDown           = false;
    var camaraCabina        = false;
    var camaraPersecucion   = false;
    var camaraPersona       = false;
    var camaraGlobal        = true;
    var mouseX              = 0.0;
    var mouseY              = 0.0;
    var rotarCamaraX        = 0.0;
    var rotarCamaraXPersona = 0.0;
    var rotarCamaraY        = -45.0;
    var rotarCamaraYPersona = 0.0;
    var aumento             = 0.0;
    var traslacionPersonaX  = -59.0;
    var traslacionPersonaZ  = 3.0;
    var traslacionNave      = vec3.create();
    vec3.set(traslacionNave, 0, 0, 0);

    // Variables de la Antena
    var desplegarAntena         = true;
    var plegarAntena            = false;
    var plegarODesplegarAntena  = false;
    var deltaAntenaTraslacion   = 0;
    var deltaAntenaRotacion     = 0;
    var traslacionPlegadoAntena = 0.0;
    var rotacionPlegadoAntena   = 0.0;
    var finRotacionAntena       = true;

    // Variables de la Nave
    var rotacionEjeNave         = -Math.PI/2;
    var cabezeoNave             = null;
    var viradaNave              = null;
    var rolidoNave              = null;
    var naveVertical            = false;
    var plegarODesplegarPatas   = false;
    var plegarPatas             = false;
    var desplegarPatas          = false;
    var traslacionPatasNave     = -4.9;
    var deltaPatas              = 0;

    // Astronauta
    var model_matrix_astronauta = null;

    // Variables de los elementos de la escena
    var nave        = null;
    var modeloNave  = null;
    var estacion    = null;
    var sol         = null;
    var tierra      = null;
    var universo    = null;
    var astronauta  = null;
    var rotacionSol = 0.0;

    // Variables de los shaders
    var shaderProgramSimple;
</script>

</head>
<body onload="start();">
    <center>
        <h1>Sistemas Gráficos - 66.71</h1>
        <h2>Trabajo Pr&aacute;ctico 2016</h2>
        <canvas id="glcanvas" style="border: none;" width="1280" height="720">
        Your browser does not support the HTML5 canvas element.
        </scanvas>
    </center>
    <br/>
    <br/>
</body>
</html>
